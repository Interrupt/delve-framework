diagnostic(off, derivative_uniformity);

alias Arr = array<vec4f, 32u>;

struct fs_params {
  /* @offset(0) */
  u_cameraPos : vec4f,
  /* @offset(16) */
  u_color_override : vec4f,
  /* @offset(32) */
  u_alpha_cutoff : f32,
  /* @offset(48) */
  u_ambient_light : vec4f,
  /* @offset(64) */
  u_dir_light_dir : vec4f,
  /* @offset(80) */
  u_dir_light_color : vec4f,
  /* @offset(96) */
  u_num_point_lights : f32,
  /* @offset(112) */
  u_point_light_data : Arr,
  /* @offset(624) */
  u_fog_data : vec4f,
  /* @offset(640) */
  u_fog_color : vec4f,
}

@group(0) @binding(8) var<uniform> x_63 : fs_params;

@group(1) @binding(64) var tex : texture_2d<f32>;

@group(1) @binding(80) var smp : sampler;

var<private> uv : vec2f;

var<private> color : vec4f;

var<private> position_1 : vec4f;

var<private> normal : vec3f;

@group(1) @binding(65) var tex_emissive : texture_2d<f32>;

var<private> frag_color : vec4f;

var<private> tangent : vec4f;

fn sqr_f1_(x : ptr<function, f32>) -> f32 {
  let x_22 : f32 = *(x);
  let x_23 : f32 = *(x);
  return (x_22 * x_23);
}

fn attenuate_light_f1_f1_f1_f1_(distance_1 : ptr<function, f32>, radius : ptr<function, f32>, max_intensity : ptr<function, f32>, falloff : ptr<function, f32>) -> f32 {
  var s : f32;
  var s2 : f32;
  var param : f32;
  var param_1 : f32;
  let x_28 : f32 = *(distance_1);
  let x_29 : f32 = *(radius);
  s = (x_28 / x_29);
  let x_31 : f32 = s;
  if ((x_31 >= 1.0f)) {
    return 0.0f;
  }
  let x_41 : f32 = s;
  param = x_41;
  let x_42 : f32 = sqr_f1_(&(param));
  s2 = x_42;
  let x_43 : f32 = *(max_intensity);
  let x_44 : f32 = s2;
  param_1 = (1.0f - x_44);
  let x_47 : f32 = sqr_f1_(&(param_1));
  let x_49 : f32 = *(falloff);
  let x_50 : f32 = s;
  return ((x_43 * x_47) / (1.0f + (x_49 * x_50)));
}

fn calcFogFactor_f1_(distance_to_eye : ptr<function, f32>) -> f32 {
  var fog_start : f32;
  var fog_end : f32;
  var fog_amount : f32;
  var fog_factor : f32;
  let x_69 : f32 = x_63.u_fog_data.x;
  fog_start = x_69;
  let x_73 : f32 = x_63.u_fog_data.y;
  fog_end = x_73;
  let x_78 : f32 = x_63.u_fog_color.w;
  fog_amount = x_78;
  let x_80 : f32 = *(distance_to_eye);
  let x_81 : f32 = fog_start;
  let x_83 : f32 = fog_end;
  let x_84 : f32 = fog_start;
  fog_factor = ((x_80 - x_81) / (x_83 - x_84));
  let x_87 : f32 = fog_factor;
  let x_88 : f32 = fog_amount;
  return clamp((x_87 * x_88), 0.0f, 1.0f);
}

fn main_1() {
  var c : vec4f;
  var lit_color : vec4f;
  var i : i32;
  var point_light_pos_data : vec4f;
  var point_light_color_data : vec4f;
  var lightPosEye : vec3f;
  var lightColor : vec3f;
  var lightMinusPos : vec3f;
  var lightDir : vec3f;
  var lightBrightness : f32;
  var dist : f32;
  var radius_1 : f32;
  var attenuation : f32;
  var param_2 : f32;
  var param_3 : f32;
  var param_4 : f32;
  var param_5 : f32;
  var lightDir_1 : vec4f;
  var lightColor_1 : vec4f;
  var lightBrightness_1 : f32;
  var e : vec4f;
  var e_amt : f32;
  var override_mod : f32;
  var fog_factor_1 : f32;
  var param_6 : f32;
  let x_108 : vec2f = uv;
  let x_109 : vec4f = textureSample(tex, smp, x_108);
  let x_112 : vec4f = color;
  c = (x_109 * x_112);
  let x_118 : vec4f = x_63.u_ambient_light;
  lit_color = x_118;
  let x_120 : f32 = c.w;
  let x_123 : f32 = x_63.u_alpha_cutoff;
  if ((x_120 <= x_123)) {
    discard;
  }
  i = 0i;
  loop {
    let x_136 : i32 = i;
    let x_139 : f32 = x_63.u_num_point_lights;
    if ((x_136 < i32(x_139))) {
    } else {
      break;
    }
    let x_144 : i32 = i;
    let x_147 : vec4f = x_63.u_point_light_data[(x_144 * 2i)];
    point_light_pos_data = x_147;
    let x_149 : i32 = i;
    let x_154 : vec4f = x_63.u_point_light_data[((x_149 * 2i) + 1i)];
    point_light_color_data = x_154;
    let x_158 : vec4f = point_light_pos_data;
    lightPosEye = vec3f(x_158.x, x_158.y, x_158.z);
    let x_161 : vec4f = point_light_color_data;
    lightColor = vec3f(x_161.x, x_161.y, x_161.z);
    let x_164 : vec3f = lightPosEye;
    let x_166 : vec4f = position_1;
    lightMinusPos = (x_164 - vec3f(x_166.x, x_166.y, x_166.z));
    let x_170 : vec3f = lightMinusPos;
    lightDir = normalize(x_170);
    let x_173 : vec3f = lightDir;
    let x_176 : vec3f = normal;
    lightBrightness = max(dot(x_173, x_176), 0.0f);
    let x_180 : vec3f = lightMinusPos;
    dist = length(x_180);
    let x_184 : f32 = point_light_pos_data.w;
    radius_1 = x_184;
    let x_187 : f32 = dist;
    param_2 = x_187;
    let x_189 : f32 = radius_1;
    param_3 = x_189;
    param_4 = 1.0f;
    param_5 = 1.0f;
    let x_192 : f32 = attenuate_light_f1_f1_f1_f1_(&(param_2), &(param_3), &(param_4), &(param_5));
    attenuation = x_192;
    let x_193 : f32 = lightBrightness;
    let x_194 : vec3f = lightColor;
    let x_196 : f32 = attenuation;
    let x_198 : vec4f = lit_color;
    let x_200 : vec3f = (vec3f(x_198.x, x_198.y, x_198.z) + ((x_194 * x_193) * x_196));
    lit_color.x = x_200.x;
    lit_color.y = x_200.y;
    lit_color.z = x_200.z;

    continuing {
      let x_208 : i32 = i;
      i = (x_208 + 1i);
    }
  }
  let x_213 : f32 = x_63.u_dir_light_dir.x;
  let x_215 : f32 = x_63.u_dir_light_dir.y;
  let x_217 : f32 = x_63.u_dir_light_dir.z;
  lightDir_1 = vec4f(x_213, x_215, x_217, 0.0f);
  let x_222 : vec4f = x_63.u_dir_light_color;
  lightColor_1 = x_222;
  let x_224 : vec4f = lightDir_1;
  let x_225 : vec3f = normal;
  let x_233 : f32 = x_63.u_dir_light_dir.w;
  lightBrightness_1 = (max(dot(x_224, vec4f(x_225.x, x_225.y, x_225.z, 0.0f)), 0.0f) * x_233);
  let x_235 : f32 = lightBrightness_1;
  let x_236 : vec4f = lightColor_1;
  let x_239 : vec4f = lit_color;
  let x_241 : vec3f = (vec3f(x_239.x, x_239.y, x_239.z) + (vec3f(x_236.x, x_236.y, x_236.z) * x_235));
  lit_color.x = x_241.x;
  lit_color.y = x_241.y;
  lit_color.z = x_241.z;
  let x_248 : vec4f = lit_color;
  let x_249 : vec4f = c;
  c = (x_249 * x_248);
  let x_256 : vec2f = uv;
  let x_257 : vec4f = textureSample(tex_emissive, smp, x_256);
  e = x_257;
  let x_260 : f32 = e.x;
  let x_262 : f32 = e.y;
  let x_265 : f32 = e.z;
  e_amt = min(((x_260 + x_262) + x_265), 1.0f);
  let x_268 : vec4f = c;
  let x_270 : f32 = e_amt;
  let x_273 : vec4f = e;
  let x_275 : vec3f = ((vec3f(x_268.x, x_268.y, x_268.z) * (1.0f - x_270)) + vec3f(x_273.x, x_273.y, x_273.z));
  c.x = x_275.x;
  c.y = x_275.y;
  c.z = x_275.z;
  let x_284 : f32 = x_63.u_color_override.w;
  override_mod = (1.0f - x_284);
  let x_286 : vec4f = c;
  let x_288 : f32 = override_mod;
  let x_291 : vec4f = x_63.u_color_override;
  let x_294 : f32 = x_63.u_color_override.w;
  let x_296 : vec3f = ((vec3f(x_286.x, x_286.y, x_286.z) * x_288) + (vec3f(x_291.x, x_291.y, x_291.z) * x_294));
  c.x = x_296.x;
  c.y = x_296.y;
  c.z = x_296.z;
  let x_305 : vec4f = x_63.u_cameraPos;
  let x_306 : vec4f = position_1;
  param_6 = length((x_305 - x_306));
  let x_310 : f32 = calcFogFactor_f1_(&(param_6));
  fog_factor_1 = x_310;
  let x_313 : vec4f = c;
  let x_316 : vec4f = x_63.u_fog_color;
  let x_318 : f32 = fog_factor_1;
  let x_320 : vec3f = mix(vec3f(x_313.x, x_313.y, x_313.z), vec3f(x_316.x, x_316.y, x_316.z), vec3f(x_318, x_318, x_318));
  frag_color = vec4f(x_320.x, x_320.y, x_320.z, 1.0f);
  return;
}

struct main_out {
  @location(0)
  frag_color_1 : vec4f,
}

@fragment
fn main(@location(1) uv_param : vec2f, @location(0) color_param : vec4f, @location(4) position_1_param : vec4f, @location(2) normal_param : vec3f, @location(3) tangent_param : vec4f) -> main_out {
  uv = uv_param;
  color = color_param;
  position_1 = position_1_param;
  normal = normal_param;
  tangent = tangent_param;
  main_1();
  return main_out(frag_color);
}

